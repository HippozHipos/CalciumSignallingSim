#pragma once

#include <vector>
#include <assert.h>
#include <iostream>
#include <algorithm>
#include "GeneratedPackedTissueInfo.hpp"
#include "GeneratedGraphTissueInfo.hpp"
#include "Cell.hpp"

///////////////////////////////////////////////////////////////////////////////////////
//PackedTissie memory representation:												 //
//Tissue is made up of layers. layer is a 2d tissue. Stack layers to make 3d tissue. //
//Each layer of tissue is a 1d-array representation of a 2d array.					 //
//Each 3d tissue is a 1d-array representation of a bunch of 2d layers.				 //
//Example: 3x3 layer (c is cell and index starts at 0)								 //
//a conceptual tissue layer:														 //
//c c c																				 //
//c c c																				 //
//c c c																				 //
//can be represented in memory as 													 //
//c c c c c c c c c																	 //
//conversion from 2d layer to 1d memory = y * layerWidth + x						 //
//concrete example: we want the the cell at x, y = 1, 2: 							 //
// y * layerWidth + x = 2 * 3 + 1 = 7th cell										 //
//Now 3x3x3 tissue would be 3 of thoose layers "stacked" on top of each other.		 //
//represented in memory as 															 //
//(layer1)c c c c c c c c c (layer2)c c c c c c c c c c (layer3)c c c c c c c c c	 //
//we can go from 3d tissue to 2d layer with: 										 //
//z * number of cells in a layer + (y * layerWidth + x):							 //
//concrete example: we want the cell at x, y, z = 1, 2, 2:							 //
//z * number of cells in a layer + (y * layerWidth + x) = 							 //
//2 * 9 + (2 * 3 + 1) = 25th cell													 //
///////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
//(All of this is true for GraphTissue as well)												//
//One other point to note is that the cells can be of any type as long as:					//
//1. They derive from StemCell<T>															//
//2. T is the same as the ValueType of the tissue.											//
//Tissues interally store a vector of StemCell<T> pointers.									//
//PackedTissueCellTypes (generated by helper tool) holds a list of types of cells			//
//that the tissue is supposed to have at correct indices									//
//(GraphTissueCellTypes for graph tissue).													//
//Tissue then uses that to allocate a contigious buffer big enough for all the cells.		//
//It then uses placement new to construct the cells of types provided by the type list		//
//at correct indices in the buffer.															//		
//////////////////////////////////////////////////////////////////////////////////////////////

//Because of the reasons mention above, when using tissues, DONT DIRECTLY ASSIGN CELLS TO THE
//TISSUE. It will make life harder since there is no way to verify the correct type is being
//assigned, which makes debugging harder. Even if the correct type is asssigned, it would break
//data continuity, which is the whole point in doing all of this. There really is no need to do it. 
//Instead just modify the values within the cells.

//Tissues are only moveable not copyable. I see 0 reasons to copy tissue.

template<class ValueType>
class PackedTissue
{
public:
	using TypeList = PackedTissueCellTypes<ValueType>;
	using CellType = StemCell<ValueType>;
	int NumGapJunctions = 1;

private:
	//used to return neighbours of any given cell
	template<size_t N>
	struct NeighboursImpl
	{
		static constexpr size_t Count = N;
		NeighboursImpl(CellType* neighbours[Count])
		{
			for (size_t i = 0; i < Count; i++)
			{
				cells[i] = neighbours[i];
			}
		}
		CellType* cells[Count];
	};

public:
	//26 is maximum of number of immediate neighbours a 
	//3d cubie can have
	using Neighbours3D = NeighboursImpl<26>;
	static constexpr uint8_t
		//this was painful
		//TODO: verified once. Check again. chance i missed something.
		Neigh3D_TopLeftFront = 0, Neigh3D_TopLeft = 1, Neigh3D_TopLeftBack = 2,
		Neigh3D_LeftFront = 3, Neigh3D_Left = 4, Neigh3D_LeftBack = 5,
		Neigh3D_BottomLeftFront = 6, Neigh3D_BottomLeft = 7, Neigh3D_BottomLeftBack = 8,
		Neigh3D_TopFront = 9, Neigh3D_Top = 10, Neigh3D_TopBack = 11,
		Neigh3D_Front = 12, Neigh3D_Back = 13,
		Neigh3D_BottomFront = 14, Neigh3D_Bottom = 15, Neigh3D_BottomBack = 16,
		Neigh3D_TopRightFront = 17, Neigh3D_TopRight = 18, Neigh3D_TopRightBack = 19,
		Neigh3D_RightFront = 20, Neigh3D_Right = 21, Neigh3D_RightBack = 22,
		Neigh3D_BottomRightFront = 23, Neigh3D_BottomRight = 24, Neigh3D_BottomRightBack = 25;

	//neighbours in 3d without diagonals -
	//left, right, up, down, front, back
	using Neighbours3DNoDiag = NeighboursImpl<6>;
	static constexpr uint8_t
		Neigh3DNoDiag_Left = 0, Neigh3DNoDiag_Right = 1, Neigh3DNoDiag_Up = 2,
		Neigh3DNoDiag_Down = 3, Neigh3DNoDiag_Front = 4, Neigh3DNoDiag_Back = 5;

	//neighbours but in 2d 
	//up, down, left, right and 4 diagonals 
	using Neighbours2D = NeighboursImpl<8>;
	static constexpr uint8_t
		Neigh2D_Left = 0, Neigh2D_Right = 1, Neigh2D_Up = 2,
		Neigh2D_Down = 3, Neigh2D_TopLeft = 4, Neigh2D_BottomLeft = 5,
		Neigh2D_TopRight = 6, Neigh2D_BottomRight = 7;

	//neighbours in 2d -
	//up, down, left, right
	using Neighbours2DNoDiag = NeighboursImpl<4>;
	static constexpr uint8_t
		Neigh2DNoDiag_Left = 0, Neigh2DNoDiag_Right = 1, Neigh2DNoDiag_Up = 2,
		Neigh2DNoDiag_Down = 3;

public:
	PackedTissue(size_t x, size_t y, size_t z) :
		m_Width{ x }, m_Height{ y }, m_Depth{ z }
	{
		TypeList typelist = TypeList{};
		constexpr size_t typeListSize = TissueCellTypeList_Size<ValueType>(typelist);
		size_t tissueSize = m_Width * m_Height * m_Depth;

		m_Cells.resize(tissueSize);

		assert(tissueSize == typeListSize && 
			"Type list size doesn't match the number of cells in the tissue");

		size_t allocSize = TissueCellTypeList_SizeBytes<ValueType>(typelist);
		m_CellStore = new uint8_t[allocSize];

		size_t offset = 0;

		TissueCellTypeList_ConstexprForEach<typeListSize>
		(
				[&offset, typelist, this](auto index)
				{
					constexpr size_t i = decltype(index)::I;
					constexpr size_t numProps = CellTypeAt<i, TypeList>::type::NumProperties;
					m_Cells[i] = new typename CellTypeAt<i, TypeList>::type
					{
						new (m_CellStore + offset) ValueType[numProps]
					};
					for (size_t j = 0; j < numProps; j++)
					{
						m_Cells[i]->SetAt(j, std::numeric_limits<ValueType>::max());
					}
					offset += numProps * sizeof(ValueType);
				}
		);
	}

	PackedTissue(PackedTissue&& other) noexcept
	{
		m_Width = other.m_Width;
		m_Height = other.m_Height;
		m_Depth = other.m_Depth;
		m_CellStore = other.m_CellStore;
		m_Cells = std::move(m_Cells);

		other.m_CellStore = nullptr;
	}

	PackedTissue& operator=(PackedTissue&& other) noexcept
	{
		if (this != &other)
		{
			m_Width = other.m_Width;
			m_Height = other.m_Height;
			m_Depth = other.m_Depth;
			m_CellStore = other.m_CellStore;
			m_Cells = std::move(m_Cells);

			other.m_CellStore = nullptr;
		}
	}

	~PackedTissue()
	{
		for (size_t i = 0; i < m_Cells.size(); i++)
		{
			delete m_Cells[i];
		}
		delete m_CellStore;
	}

public:
	CellType* GetCell(size_t x, size_t y, size_t z)
	{
		return m_Cells[Index(x, y, z)]; 
	}

	const CellType* const GetCellAt(size_t x, size_t y, size_t z) const 
	{ 
		return m_Cells[Index(x, y, z)]; 
	}

	CellType* const GetCell(size_t i)
	{
		return m_Cells[i];
	}

	const CellType* GetCellAt(size_t i) const 
	{ 
		return m_Cells[i];
	}

	//the 2d axis is always the same as the layer axis.
	Neighbours2D GetNeighbours2D(size_t x, size_t y, size_t z)
	{
		assert((x <= m_Width - 1) && (y <= m_Height - 1) && (x <= m_Depth - 1));
		CellType* cells[Neighbours2D::Count] = { nullptr };
		if (x > 0)
			cells[0] = GetCell(x - 1, y, z);//left
		if (x < Width() - 1)
			cells[1] = GetCell(x + 1, y, z);//right
		if (y > 0)
			cells[2] = GetCell(x, y - 1, z);//up
		if (y < Height() - 1)
			cells[3] = GetCell(x, y + 1, z);//down
		if (x > 0 && y > 0)
			cells[0] = GetCell(x - 1, y - 1, z);//top-left
		if (x > 0 && y < Height() - 1)
			cells[0] = GetCell(x - 1, y + 1, z);//bottom-left
		if (x < Width() - 1 && y > 0)
			cells[0] = GetCell(x + 1, y - 1, z);//top-right
		if (x < Width() - 1 && y < Height() - 1)
			cells[0] = GetCell(x + 1, y + 1, z);//bottom-right
		return Neighbours2D{ cells };
	}

	Neighbours2DNoDiag GetNeighbours2DNoDiag(size_t x, size_t y, size_t z)
	{
		assert((x <= m_Width - 1) && (y <= m_Height - 1) && (x <= m_Depth - 1));
		CellType* cells[Neighbours2DNoDiag::Count] = { nullptr };
		if (x > 0)
			cells[0] = GetCell(x - 1, y, z);//left
		if (x < Width() - 1)
			cells[1] = GetCell(x + 1, y, z);//right
		if (y > 0)
			cells[2] = GetCell(x, y - 1, z);//up
		if (y < Height() - 1)
			cells[3] = GetCell(x, y + 1, z);//down
		return Neighbours2DNoDiag{ cells };
	}

	Neighbours3D GetNeighbours3D(size_t x, size_t y, size_t z)
	{
		assert((x <= m_Width - 1) && (y <= m_Height - 1) && (x <= m_Depth - 1));
		CellType* cells[Neighbours3D::Count] = { nullptr };
		size_t index = 0;

		for (int xx = -1; xx <= 1; xx++)
		{
			for (int yy = -1; yy <= 1; yy++)
			{
				for (int zz = -1; zz <= 1; zz++)
				{
					if (xx == 0 && yy == 0 && zz == 0)
					{
						continue;
					}

					int _x = xx + x; int _y = yy + y; int _z = zz + z;
					if (_x >= 0 && _x < Width() && _y >= 0 && _y < Height() && _z >= 0 && _z < Depth())
					{
						cells[index] = GetCell(_x, _y, _z);
					}
					index++;
				}
			}
		}

		return Neighbours3D{ cells };
	}

	Neighbours3DNoDiag GetNeighbours3DNoDiag(size_t x, size_t y, size_t z)
	{
		CellType* cells[Neighbours3DNoDiag::Count] = { nullptr };
		if (x > 0)
			cells[0] = GetCell(x - 1, y, z);//left
		if (x < Width() - 1)
			cells[1] = GetCell(x + 1, y, z);//right
		if (y > 0)
			cells[2] = GetCell(x, y - 1, z);//up
		if (y < Height() - 1)
			cells[3] = GetCell(x, y + 1, z);//down
		if (z > 0)
			cells[4] = GetCell(x, y, z - 1);//front
		if (z < Depth() - 1)
			cells[5] = GetCell(x, y, z + 1);//back
		return Neighbours3DNoDiag{ cells };
	}

public:
	size_t Width() const { return m_Width; }
	size_t Height() const { return m_Height; }
	size_t Depth() const { return m_Depth; }
	size_t Size() const { return Width() * Height() * Depth(); }

public:
	size_t Index(size_t x, size_t y, size_t z) const
	{
		assert((x >= 0) && (y >= 0) && (z >= 0));
		assert((x <= m_Width - 1) && (y <= m_Height - 1) && (x <= m_Depth - 1));
		return z * (m_Width * m_Height) + (y * m_Width + x);
	}

	void Index(size_t index, size_t& x, size_t& y, size_t& z) const
	{
		assert(index < (m_Width* m_Height* m_Depth));
		z = index / (m_Width * m_Height);
		y = (index % (m_Width * m_Height)) / m_Width;
		x = (index % (m_Width * m_Height)) % m_Width;
	}

private:
	size_t m_Width;
	size_t m_Height;
	size_t m_Depth;

	//heap pointer where cells are stored
	uint8_t* m_CellStore;

	//pointers to individual cells within m_CellStore.
	//vector never resizes
	std::vector<CellType*> m_Cells;
};

//for convenience 
//values = float
using PackedTissueF = PackedTissue<float>;

//values = double
using PackedTissueD = PackedTissue<double>;

////////////////////////////////////////////////////////////////////////////////
//GraphTissue is a tissue class that lets you specify the connections between //
//cells and the number of gap junctions between them. It provides interface   //
//to add cells to it, retrieve cells, the connections between cells, and the  //
//gap junctions.															  //
////////////////////////////////////////////////////////////////////////////////

template<class ValueType>
class GraphTissue
{
public:
	using TypeList = GraphTissueCellTypes<ValueType>;
	using CellType = StemCell<ValueType>;

	struct Entry
	{
		Entry(size_t size) 
		{ connections.reserve(size); gapJunctions.reserve(size); }
		std::vector<size_t> connections;
		std::vector<size_t> gapJunctions;
		CellType* cell = nullptr;
	};

	struct EntryView
	{
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> connections;
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> gapJunctions;
		CellType* cell = nullptr;
	};

	GraphTissue()
	{
		TypeList typelist = TypeList{};
		constexpr size_t typeListSize = TissueCellTypeList_Size<ValueType>(typelist);

		m_Cells.resize(typeListSize);

		assert(typeListSize == GraphTissueConnections.size() &&
			GraphTissueConnections.size() == GraphTissueGapJunctions.size() &&
			"Invalid Tissue info");

		size_t allocSize = TissueCellTypeList_SizeBytes<ValueType>(typelist);
		m_CellStore = new uint8_t[allocSize];

		size_t offset = 0;

		TissueCellTypeList_ConstexprForEach<typeListSize>
			(
				[&offset, typelist, this](auto index)
				{
					constexpr size_t i = decltype(index)::I;
					constexpr size_t numProps = CellTypeAt<i, TypeList>::type::NumProperties;
					m_Cells[i] = new typename CellTypeAt<i, TypeList>::type
					{
						new (m_CellStore + offset) ValueType[numProps]
					};
					for (size_t j = 0; j < numProps; j++)
					{
						m_Cells[i]->SetAt(j, std::numeric_limits<ValueType>::max());
					}
					SetCellConnectionsAndGapJunctions(
						*(GraphTissueConnections.begin() + i),
						*(GraphTissueGapJunctions.begin() + i),
						i);
					offset += numProps * sizeof(ValueType);;
				}
		);
	}

	GraphTissue(GraphTissue&& other) noexcept
	{
		m_Connections = std::move(m_Connections);
		m_GapJunctions = std::move(m_GapJunctions);
		m_CellStore = other.m_CellStore;
		m_Cells = std::move(m_Cells);

		other.m_CellStore = nullptr;
	}

	GraphTissue& operator=(GraphTissue&& other) noexcept
	{
		if (this != &other)
		{
			m_Connections = std::move(m_Connections);
			m_GapJunctions = std::move(m_GapJunctions);
			m_CellStore = other.m_CellStore;
			m_Cells = std::move(m_Cells);

			other.m_CellStore = nullptr;
		}
	}

	~GraphTissue()
	{
		for (size_t i = 0; i < m_Cells.size(); i++)
		{
			delete m_Cells[i];
		}
		delete m_CellStore;
	}

public:
	CellType* GetCell(size_t index)
	{
		return m_Cells[index];
	}

	const CellType* GetCell(size_t index) const
	{
		return m_Cells[index];
	}

	Entry GetEntry(size_t index)
	{
		assert(index < m_Cells.size() && "Index out of range");
		std::vector<size_t> connections;
		std::vector<size_t> gapJunctions;
		GetConnectionsAndGapJunctions(index, connections, gapJunctions);
		Entry e{ connections.size() };
		e.cell = m_Cells[index];
		e.connections = std::move(connections);
		e.gapJunctions = std::move(gapJunctions);
		return e;
	}

	EntryView GetEntryView(size_t index)
	{
		assert(index < m_Cells.size());
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> connections;
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> gapJunctions;
		GetConnectionsAndGapJunctionsView(index, connections, gapJunctions);
		EntryView e{};
		e.cell = m_Cells[index];
		e.connections = connections;
		e.gapJunctions = gapJunctions;
		return e;
	}

	std::vector<size_t> GetConnections(size_t index)
	{
		return GetConnectionsOrGapJunctions(index, m_Connections);
	}

	std::vector<size_t> GetGapJunctions(size_t index)
	{
		return GetConnectionsOrGapJunctions(index, m_GapJunctions);
	}

	std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> 
	GetConnectionsView(size_t index)
	{
		return GetConnectionsOrGapJunctionsView(index, m_Connections);
	}

	std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator>
	GetGapJunctionsView(size_t index)
	{
		return GetConnectionsOrGapJunctionsView(index, m_GapJunctions);
	}

	void GetConnectionsAndGapJunctions(size_t index,
		std::vector<size_t>& connections,
		std::vector<size_t>& gapJunctions)
	{
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> con;
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> gap;
		GetConnectionsAndGapJunctionsView(index, con, gap);
		size_t diff = con.second - con.first;
		connections.reserve(diff);
		gapJunctions.reserve(diff);
		for (size_t i = 0; i < diff; i++)
		{
			connections.push_back(con.first[i]);
			gapJunctions.push_back(gap.first[i]);
		}	
	}

	void GetConnectionsAndGapJunctionsView(size_t index,
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator>& connections,
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator>& gapJunctions)
	{
		assert(index < m_Cells.size());
		size_t itStartIndex = 0;
		for (size_t i = 0; i < index; i++)
		{
			itStartIndex += m_Connections[itStartIndex] + 1;
		}
		//at this point value at itStartIndex is the count
		//PushBack guarantees that count will be same for both of them
		assert(m_Connections[itStartIndex] == m_GapJunctions[itStartIndex]);

		size_t count = m_Connections[itStartIndex];
		itStartIndex++;

		connections.first = m_Connections.begin() + itStartIndex;
		connections.second = connections.first + count;

		gapJunctions.first = m_GapJunctions.begin() + itStartIndex;
		gapJunctions.second = gapJunctions.first + count;
	}

	bool ConnectionExists(size_t index1, size_t index2)
	{
		auto it1 = GetConnectionsView(index1);
		for (auto it = it1.first; it < it1.second; it++)
		{
			if (*it == index2)
				return true;
		}

		auto it2 = GetConnectionsView(index2);
		for (auto it = it2.first; it < it2.second; it++)
		{
			if (*it == index1)
				return true;
		}

		return false;
	}

private:
	template<class T1, class T2>
	void SetCellConnectionsAndGapJunctions(
		T1 connectionss, T2 gapJunctionss,
		size_t index)
	{
		std::vector<size_t> con = connectionss;

		assert(con.size() && gapJunctionss.size() &&
			"Cannot have cell without connections."
			"Jap junction must be specified for each connection");

		RemoveDuplicates(con);

		assert(con.size() == gapJunctionss.size() &&
			"There must be the same number of gap junctions as connections."
			"This could also happen because of duplicate connections in the same cell"
			"as duplicates are removed.");


		const size_t conSizeIndex = m_Connections.size();
		const size_t gapSizeIndex = m_GapJunctions.size();
		m_Connections.push_back(con.size());
		m_GapJunctions.push_back(gapJunctionss.size());

		//so that it works with vector and initializer list
		auto connections = con.begin();
		auto gapJunctions = gapJunctionss.begin();

		//add the entry
		for (size_t i = 0; i < con.size(); i++)
		{
			assert(connections[i] != index &&
				"Cell cannot have connection to itself");
			assert(gapJunctions[i] != index &&
				"Cell cannot have gap junction to itself");

			if (connections[i] < index)
			{
				//check if there is a connection from other cell to this one
				//other cell is the cell that we are trying to add the connection to
				auto connectionOther = GetConnectionsView(connections[i]);
				if (
					std::find(connectionOther.first, connectionOther.second, index)
													== 
										connectionOther.second
					)
				{
					//connection doesnt exist so add it
					m_Connections.push_back(connections[i]);
					m_GapJunctions.push_back(gapJunctions[i]);
				}
				else
				{
					//connection already exists from the other cell, so decrement our connections
					//count. Also the other cell will have stored the number of gap junctions as
					//well so decrement the count of gap junctions since we wont be storing it in
					//this cell.
					m_Connections[conSizeIndex]--;
					m_GapJunctions[gapSizeIndex]--;
				}
			}
			else
			{
				//connection attempt to a cell that doesnt exist yet. Allow it
				//since this cell might be added later. It the connection is 
				//accessed without adding the cell then GG.
				m_Connections.push_back(connections[i]);
				m_GapJunctions.push_back(gapJunctions[i]);
			}
		}
	}

	void SetCellConnectionsAndGapJunctions(
		const std::initializer_list<size_t>& connections,
		const std::initializer_list<size_t>& gapJunctions, 
		size_t index)
	{
		SetCellConnectionsAndGapJunctions(connections, gapJunctions, index);
	}

	void SetCellConnectionsAndGapJunctions(
		const std::vector<size_t>& connections,
		const std::vector<size_t>& gapJunctions, 
		size_t index)
	{
		SetCellConnectionsAndGapJunctions(connections, gapJunctions, index);
	}

	std::vector<size_t> 
	GetConnectionsOrGapJunctions(size_t index, std::vector<size_t>& data)
	{
		std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> it =
			GetConnectionsOrGapJunctionsView(index, data);
		
		std::vector<size_t> out;
		out.reserve(it.second - it.first);
		for (auto _it = it.first; _it < it.second; _it++)
		{
			out.push_back(*_it);
		}
		return out;
	}

	std::pair<std::vector<size_t>::iterator, std::vector<size_t>::iterator> 
	GetConnectionsOrGapJunctionsView(size_t index, std::vector<size_t>& data)
	{
		assert(index < m_Cells.size());
		size_t itStartIndex = 0;
		for (size_t i = 0; i < index; i++)
		{
			itStartIndex += data[itStartIndex] + 1;
		}

		size_t count = data[itStartIndex];
		itStartIndex++;

		auto begin = data.begin() + itStartIndex;
		auto end = begin + count;

		return std::pair<std::vector<size_t>::iterator,
			std::vector<size_t>::iterator>(begin, end);
	}

	void RemoveDuplicates(std::vector<size_t>& data)  const
	{
		std::sort(data.begin(), data.end());
		for (int i = 0; i < data.size() - 1; i++)
		{
			if (data[i] == data[i + 1])
			{
				data.erase(data.begin() + i);
				i--;
			}
		}
	}

public:
	//TODO:
	//WE NEED AN ITERATOR FOR THIS CLASS AS WELL SINCE LOOPING FROM THE BEGINNING
	//FOR EACH ENTRY TAKES TIME. 


private:
	//stores connections of the cells
	//format: Count(4) value value value value Count(1) value  
	//Count: How many connections
	//value: Index into m_Cells array to specify which cell the connections is to
	std::vector<size_t> m_Connections;

	//specifies the number of gap junction between each connection.
	//the position in the array corrolates to which cell the connection
	//is to. 
	//format same as m_Connections
	std::vector<size_t> m_GapJunctions;

	//heap pointer where cells are stored
	uint8_t* m_CellStore;

	//pointers to individual cells within m_CellStore.
	//vector never resizes
	std::vector<CellType*> m_Cells;
};

//for convenience 
//values = float
using GraphTissueF = GraphTissue<float>;

//values = double
using GraphTissueD = GraphTissue<double>;